project.logger.lifecycle("Loading NeoForge project module. Using Mixins: ${project.hasProperty('mixin_id')}")

buildscript {

    repositories {

        maven {

            name 'Official NeoForge Maven'
            url 'https://maven.neoforged.net'
        }

        maven {
            name 'Sponge / Mixin Maven'
            url 'https://repo.spongepowered.org/repository/maven-public'
        }

        maven {
            name 'ParchmentMC'
            url 'https://maven.parchmentmc.org'
        }

        mavenCentral()
    }
    dependencies {
        classpath 'net.neoforged.gradle:userdev:7.0.57'
    }

}

apply plugin: net.neoforged.gradle.userdev.UserDevPlugin
apply from: 'gradle/property_helper.gradle'

// Configurable Forge Properties
def neoforgeVersion = getRequiredString('forge_version')
def clientRunDir = getDefaultString('forge_client_dir', 'run')
def serverRunDir = getDefaultString('forge_server_dir', 'run')
def loggingLevel = getDefaultString('forge_log_level', 'debug')
def loggingANSI = getDefaultProperty('forge_log_ansi', true).asBoolean()
def mappingChannel = getDefaultString('forge_mapping_channel', 'official')
def mappingVersion = getDefaultString('forge_mapping_version', project.ext.mcVersion)
def mod_id = getRequiredString('mod_id')
def minecraft_version = getRequiredString('minecraft_version')

// Mixin Options
def remapRefmap = getDefaultBoolean('mixin_remap_refmap')
def remapRefmapFile = getDefaultString('mixin_remap_refmap_file', "${projectDir}/build/createSrgToMcp/output.srg")

// Makes sure jar files are reobfuscated by Forge when built.
minecraft.accessTransformers.file file(project.findProperty('forge_at'))

runs {

    client {
        // Sets the folder the client runs in.
        workingDirectory project.file(clientRunDir)

        // Sets the name of the run to include the mod name.
        // TODO: NeoGradle
        // taskName modName.replaceAll("\\s", "") + 'Client'

        // Sets Forge's logging level on the client.
        systemProperty 'forge.logging.console.level', loggingLevel

        // Enables ANSI color codes in the logs.
        if (loggingANSI) {

            systemProperty 'terminal.ansi', 'true'
        }

        modSource project.sourceSets.main
    }

    server {

        // Sets the folder the server runs in.
        workingDirectory project.file(serverRunDir)

        // Sets the name of the run to include the mod name.
        // TODO: NeoGradle
        // taskName modName.replaceAll("\\s", "") + 'Server'

        // Sets Forge's logging level on the server.
        systemProperty 'forge.logging.console.level', loggingLevel

        // Enables ANSI color codes in the logs.
        if (loggingANSI) {

            systemProperty 'terminal.ansi', 'true'
        }

        modSource project.sourceSets.main
    }

    data {
        // Sets the folder the server runs in.
        workingDirectory project.file(clientRunDir)

        // Sets the name of the run to include the mod name.
        // taskName modName.replaceAll("\\s", "") + 'Data'

        // Sets Forge's logging level on the server.
        systemProperty 'forge.logging.console.level', loggingLevel
        // environment 'target', 'fmluserdevdata'

        // Enables ANSI color codes in the logs.
        if (loggingANSI) {
            systemProperty 'terminal.ansi', 'true'
        }

        programArguments.addAll '--mod', modId, '--all', '--output', '"' + rootProject.file('src/generated/resources/') + '"', '--existing', '"' + rootProject.file('src/main/resources') + '"'

        modSource project.sourceSets.main
    }
}

dependencies {
    // Sets Minecraft and Forge as a dependency for the project.
    implementation "net.neoforged:neoforge:${neoforgeVersion}"
}


processResources {
    duplicatesStrategy = 'exclude'

    def buildProps = project.properties.clone()
    from(sourceSets.main.resources.srcDirs) {

        if (project.ext.has('patreon') && project.ext.patreon.pledges && !project.ext.patreon.pledges.isEmpty()) {

            def supporters = new ArrayList<String>()

            for (entry in project.ext.patreon.pledges) {

                def pledge = entry.getValue();

                if (pledge.isValid()) {

                    supporters.add(pledge.getDisplayName())
                }
            }

            buildProps.put('modCredits', "${project.ext.modCredits} and the supporters on Patreon: ${supporters.join(', ')}")
        }
    }

    filesMatching(['META-INF/mods.toml', 'pack.mcmeta']) {
        expand buildProps
    }
}

sourceSets.main.resources {
    srcDir 'src/generated/resources'
}

jar {

    manifest {

        def newProps = [:]

        // Adds build time info to the manifest. This has no intended runtime
        // functionality.
        newProps['ModLoader'] = "neoforge-${neoforgeVersion}"
        newProps['Built-On-Minecraft'] = project.ext.mcVersion
        newProps['Built-On-Mapping'] = "${mappingChannel}-${mappingVersion}"

        // Adds the mixin config to the manifest when mixins are used. This is
        // required for your mixins to run.
        if (project.hasProperty('mixin_id')) {

            newProps['MixinConfigs'] = "${mixin_id}.mixins.json"
        }

        attributes(newProps)
    }
}

// Forge normally generates this task, but by giving the run config a unique
// name for multi-project workspaces we also change the name of the generated
// task. Some 3rd party tools depend on these tasks existing so we recreate
// them here.
// TODO: Investigate whether we need to replace task names with NeoGradle
/*
task runClient() {

    description = 'Runs the game client in developer/debug mode.'
    dependsOn modName.replaceAll("\\s", "") + 'Client'
}

task runServer() {

    description = 'Runs the game server in developer/debug mode.'
    dependsOn modName.replaceAll("\\s", "") + 'Server'
}
 */

// Forge's Jar Signer
def canSignJar = project.hasProperty('keyStore') && project.hasProperty('keyStorePass') && project.hasProperty('keyStoreKeyPass') && project.hasProperty('keyStoreAlias')

task signJar(type: net.neoforged.gradle.common.tasks.PotentiallySignJar, dependsOn: jar) {
    onlyIf {

        canSignJar
    }

    if (canSignJar) {

        keyStore = project.findProperty('keyStore')
        alias = project.findProperty('keyStoreAlias')
        storePass = project.findProperty('keyStorePass')
        keyPass = project.findProperty('keyStoreKeyPass')
        inputFile = jar.archivePath
        outputFile = jar.archivePath

        build.dependsOn signJar
    } else {

        project.logger.warn('Jar signing is disabled for this build. One or more keyStore properties are not specified.')
    }
}

task setupDebugRunConfigs() {

    description = 'Creates basic configs used to debug mods in game'

    dependsOn 'configServerProps'
    dependsOn 'configEula'
}

task configServerProps(type: WriteProperties) {

    description = 'Configures the server with default properties. Eg. Disables online mode.'

    outputFile = file("${serverRunDir}/server.properties")

    property('online-mode', getDefaultString('server_online_mode', 'false'))
    property('motd', getDefaultString('server_motd', "Testing server for ${project.modName}"))
    property('server-ip', getDefaultString('server_ip', ''))
    property('server-port', getDefaultString('server_port', '25565'))
    property('snooper-enabled', getDefaultString('server_snooper_enabled', 'false'))
    property('spawn-protection', getDefaultString('server_spawn_protection', '0'))
    property('enable-command-block', getDefaultString('enable_command_block', 'true'))

    property('level-name', getDefaultString('level_name', project.modName))
    property('level-seed', getDefaultString('level_seed', project.modName))
    property('level-type', getDefaultString('level_type', 'default'))
}

task configEula(type: WriteProperties) {

    description = 'Automatically creates and agrees to the Mojang account EULA.'

    outputFile = file("${serverRunDir}/eula.txt")

    property 'eula', true

    doLast {

        project.logger.warn("You have agreed to Mojang's EULA! https://account.mojang.com/documents/minecraft_eula");
    }
}
